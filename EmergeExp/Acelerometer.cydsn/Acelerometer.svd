<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_0.xsd">
  <name>CY8C4247AZI_M485</name>
  <version>0.1</version>
  <description>PSoC 4200M</description>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <peripherals>
    <peripheral>
      <name>DMAC</name>
      <description>DMAC Registers</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DMAC_CTL</name>
          <description>DMA controller control register</description>
          <addressOffset>0x40101000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Global DMAC enable</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>DMA controller is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>DMA controller is enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS</name>
          <description>DMA controller status register</description>
          <addressOffset>0x40101010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Specifies the index of the currently active data transfer. This value increases from '0' to the DATA_NR field specified of the currently active descriptor control word.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_ADDR</name>
              <description>Specifies the channel number of the currently active channel. For example, if channel 7 is active, DMAC_STATUS.ACTIVE is '1' and STATUS.CH_ADDR is '7'.</description>
              <lsb>16</lsb>
              <msb>20</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the data transfer engine.</description>
              <lsb>24</lsb>
              <msb>26</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <description>Idle state when the DMA is not active.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOAD_DESCR</name>
                  <description>The DMA is loading the descriptor to the DMA transfer engine.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOAD_SRC</name>
                  <description>The DMA is getting the value from the source location.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_DST</name>
                  <description>The DMA is storing the value at the destination location.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_DESCR</name>
                  <description>The DMA is updating the descriptors after completion of transfer.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_TRIG_DEACT</name>
                  <description>The DMA is waiting for the level sensitive trigger to deactivate.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_ERROR</name>
                  <description>There was an error during the transaction and the DMA is writing the error code to the channel status register.</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Specifies the priority of the currently active channel.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Specifies whether the PING descriptor ('0') or PONG descriptor ('1') of the channel is currently in use.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Specifies if there is a currently active (pending) channel in the data transfer engine.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <description>No currently active channel.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>Currently active channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_SRC_ADDR</name>
          <description>Source address currently being used by the DMA controller</description>
          <addressOffset>0x40101014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The source address currently being used by the DMA transfer engine. This field is provided for debug purposes. Note while reading the DMAC_STATUS, DMAC_STATUS_SRC_ADDR and DMAC_STATUS_DST_ADDR registers, the transfer engine may have advanced after one or more of these reads. Meaning the register values may not be related to each other.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_DST_ADDR</name>
          <description>Destination address currently being used by the DMA controller</description>
          <addressOffset>0x40101018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The destination address currently being used by the DMA transfer engine. This field is provided for debug purposes. Note while reading the DMAC_STATUS, DMAC_STATUS_SRC_ADDR and DMAC_STATUS_DST_ADDR registers, the transfer engine may have advanced after one or more of these reads. Meaning the register values may not be related to each other.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_CH_ACT</name>
          <description>Channel activation status</description>
          <addressOffset>0x4010101C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Channel activation status. Bit i is associated to channel i. Software reads this field to get information on all actively pending channels (either in pending or in the data transfer engine).</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL0</name>
          <description>DMA channel 0 control register</description>
          <addressOffset>0x40101080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL1</name>
          <description>DMA channel 1 control register</description>
          <addressOffset>0x40101084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL2</name>
          <description>DMA channel 2 control register</description>
          <addressOffset>0x40101088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL3</name>
          <description>DMA channel 3 control register</description>
          <addressOffset>0x4010108C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL4</name>
          <description>DMA channel 4 control register</description>
          <addressOffset>0x40101090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL5</name>
          <description>DMA channel 5 control register</description>
          <addressOffset>0x40101094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL6</name>
          <description>DMA channel 6 control register</description>
          <addressOffset>0x40101098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL7</name>
          <description>DMA channel 7 control register</description>
          <addressOffset>0x4010109C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x401017F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x401017F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x401017F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Mask for corresponding field in INTR register.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x401017FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Bitwise AND between the interrupt reguest (INTR) and mask (INTR_MASK) registers.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 0</description>
          <addressOffset>0x40101800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 0</description>
          <addressOffset>0x40101804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_CTL</name>
          <description>Descriptor 0 control register for channel 0</description>
          <addressOffset>0x40101808</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 0</description>
          <addressOffset>0x4010180C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 0</description>
          <addressOffset>0x40101810</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 0</description>
          <addressOffset>0x40101814</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 0</description>
          <addressOffset>0x40101818</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 0</description>
          <addressOffset>0x4010181C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 1</description>
          <addressOffset>0x40101820</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 1</description>
          <addressOffset>0x40101824</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_CTL</name>
          <description>Descriptor 0 control register for channel 1</description>
          <addressOffset>0x40101828</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 1</description>
          <addressOffset>0x4010182C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 1</description>
          <addressOffset>0x40101830</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 1</description>
          <addressOffset>0x40101834</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 1</description>
          <addressOffset>0x40101838</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 1</description>
          <addressOffset>0x4010183C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 2</description>
          <addressOffset>0x40101840</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 2</description>
          <addressOffset>0x40101844</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_CTL</name>
          <description>Descriptor 0 control register for channel 2</description>
          <addressOffset>0x40101848</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 2</description>
          <addressOffset>0x4010184C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 2</description>
          <addressOffset>0x40101850</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 2</description>
          <addressOffset>0x40101854</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 2</description>
          <addressOffset>0x40101858</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 2</description>
          <addressOffset>0x4010185C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 3</description>
          <addressOffset>0x40101860</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 3</description>
          <addressOffset>0x40101864</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_CTL</name>
          <description>Descriptor 0 control register for channel 3</description>
          <addressOffset>0x40101868</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 3</description>
          <addressOffset>0x4010186C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 3</description>
          <addressOffset>0x40101870</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 3</description>
          <addressOffset>0x40101874</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 3</description>
          <addressOffset>0x40101878</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 3</description>
          <addressOffset>0x4010187C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 4</description>
          <addressOffset>0x40101880</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 4</description>
          <addressOffset>0x40101884</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_CTL</name>
          <description>Descriptor 0 control register for channel 4</description>
          <addressOffset>0x40101888</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 4</description>
          <addressOffset>0x4010188C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 4</description>
          <addressOffset>0x40101890</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 4</description>
          <addressOffset>0x40101894</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 4</description>
          <addressOffset>0x40101898</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 4</description>
          <addressOffset>0x4010189C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 5</description>
          <addressOffset>0x401018A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 5</description>
          <addressOffset>0x401018A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_CTL</name>
          <description>Descriptor 0 control register for channel 5</description>
          <addressOffset>0x401018A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 5</description>
          <addressOffset>0x401018AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 5</description>
          <addressOffset>0x401018B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 5</description>
          <addressOffset>0x401018B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 5</description>
          <addressOffset>0x401018B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 5</description>
          <addressOffset>0x401018BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 6</description>
          <addressOffset>0x401018C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 6</description>
          <addressOffset>0x401018C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_CTL</name>
          <description>Descriptor 0 control register for channel 6</description>
          <addressOffset>0x401018C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 6</description>
          <addressOffset>0x401018CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 6</description>
          <addressOffset>0x401018D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 6</description>
          <addressOffset>0x401018D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 6</description>
          <addressOffset>0x401018D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 6</description>
          <addressOffset>0x401018DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 7</description>
          <addressOffset>0x401018E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 7</description>
          <addressOffset>0x401018E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_CTL</name>
          <description>Descriptor 0 control register for channel 7</description>
          <addressOffset>0x401018E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 7</description>
          <addressOffset>0x401018EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 7</description>
          <addressOffset>0x401018F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 7</description>
          <addressOffset>0x401018F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 7</description>
          <addressOffset>0x401018F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 7</description>
          <addressOffset>0x401018FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC</name>
      <description>Sequencing SAR ADC</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Analog control register</description>
          <addressOffset>0x403A0000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VREF_SEL</name>
              <description>SARADC internal VREF selection</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>VREF_BYP_CAP_EN</name>
              <description>VREF bypass cap enable for when VREF buffer is on</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_SEL</name>
              <description>SARADC internal NEG selection for Single ended conversion</description>
              <lsb>9</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAR_HW_CTRL_NEGVREF</name>
              <description>Hardware control: 0=firmware, 1=hardware.</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_CTRL_VREF</name>
              <description>VREF buffer low power mode.</description>
              <lsb>14</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE</name>
              <description>Spare controls</description>
              <lsb>16</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ICONT_LV</name>
              <description>SARADC low power mode</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_CONFIG</name>
              <description>Synchronize the DSI config signals to peripheral clock domain</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_MODE</name>
              <description>SAR sequencer takes configuration from DSI signals</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_DISABLE</name>
              <description>Disable SAR sequencer from enabling routing switches</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>0: SAR IP disabled, 1: SAR IP enabled.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_CTRL</name>
          <description>Sample control register</description>
          <addressOffset>0x403A0004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SUB_RESOLUTION</name>
              <description>Conversion resolution for channels that have sub-resolution enabled (RESOLUTION=1) (otherwise resolution is 12-bit).</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LEFT_ALIGN</name>
              <description>Left align data in data[15:0], default data is right aligned in data[11:0], with sign extension to 16 bits if the channel is differential.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SINGLE_ENDED_SIGNED</name>
              <description>Output data from a single ended conversion as a signed value</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFERENTIAL_SIGNED</name>
              <description>Output data from a differential conversion as a signed value</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_CNT</name>
              <description>Averaging Count for channels that have over sampling enabled</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_SHIFT</name>
              <description>Averaging shifting: after averaging the result is shifted right to fit in the sample resolution, i.e. 12 bits.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CONTINUOUS</name>
              <description>0: Wait for next FW_TRIGGER or hardware trigger before scanning enabled channels. 1: Continuously scan enabled channels..</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_EN</name>
              <description>0: firmware trigger only, 1: enable hardware (DSI) trigger.</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_LEVEL</name>
              <description>0: DSI trigger signal is a pulse input, 1: DSI trigger signal is a level inpu.t</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_TRIGGER</name>
              <description>0: bypass clock domain synchronisation of the DSI trigger signal, 1: synchronize the DSI trigger signal to the SAR clock domain.</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EOS_DSI_OUT_EN</name>
              <description>Enable to output EOS_INTR to DSI</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_TIME01</name>
          <description>Sample time specification ST0 and ST1</description>
          <addressOffset>0x403A0010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME0</name>
              <description>Sample time0 (aperture) in ADC clock cycles</description>
              <lsb>0</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME1</name>
              <description>Sample time1</description>
              <lsb>16</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_TIME23</name>
          <description>Sample time specification ST2 and ST3</description>
          <addressOffset>0x403A0014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME2</name>
              <description>Sample time2</description>
              <lsb>0</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME3</name>
              <description>Sample time3</description>
              <lsb>16</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_THRES</name>
          <description>Global range detect threshold register</description>
          <addressOffset>0x403A0018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RANGE_LOW</name>
              <description>Low threshold for range detect</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE_HIGH</name>
              <description>High threshold for range detect</description>
              <lsb>16</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_COND</name>
          <description>Global range detect mode register</description>
          <addressOffset>0x403A001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RANGE_COND</name>
              <description>Range condition select</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_EN</name>
          <description>Enable bits for the channels</description>
          <addressOffset>0x403A0020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CHAN_EN</name>
              <description>Channel enable. 0: the corresponding channel is disabled. 1: the corresponding channel is enabled, it will be included in the next scan.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>START_CTRL</name>
          <description>Start control register (firmware trigger)</description>
          <addressOffset>0x403A0024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>FW_TRIGGER</name>
              <description>When firmware writes a 1 here it will trigger the next scan of enabled channels</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_CTRL</name>
          <description>DFT control register</description>
          <addressOffset>0x403A0030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>CHAN_CONFIG0</name>
          <description>Channel0 configuration register</description>
          <addressOffset>0x403A0080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s).</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel.</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_CONFIG1</name>
          <description>Channel1 configuration register</description>
          <addressOffset>0x403A0084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s).</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel.</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_CONFIG2</name>
          <description>Channel2 configuration register</description>
          <addressOffset>0x403A0088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s).</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel.</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_CONFIG3</name>
          <description>Channel3 configuration register</description>
          <addressOffset>0x403A008C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s).</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel.</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_CONFIG4</name>
          <description>Channel4 configuration register</description>
          <addressOffset>0x403A0090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s).</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel.</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_CONFIG5</name>
          <description>Channel5 configuration register</description>
          <addressOffset>0x403A0094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s).</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel.</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_CONFIG6</name>
          <description>Channel6 configuration register</description>
          <addressOffset>0x403A0098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s).</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel.</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_CONFIG7</name>
          <description>Channel7 configuration register</description>
          <addressOffset>0x403A009C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel</description>
              <lsb>4</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s).</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel.</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK0</name>
          <description>Channel0 working data register</description>
          <addressOffset>0x403A0100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_CHAN_WORK_VALID register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK1</name>
          <description>Channel1 working data register</description>
          <addressOffset>0x403A0104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_CHAN_WORK_VALID register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK2</name>
          <description>Channel2 working data register</description>
          <addressOffset>0x403A0108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_CHAN_WORK_VALID register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK3</name>
          <description>Channel3 working data register</description>
          <addressOffset>0x403A010C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_CHAN_WORK_VALID register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK4</name>
          <description>Channel4 working data register</description>
          <addressOffset>0x403A0110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_CHAN_WORK_VALID register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK5</name>
          <description>Channel5 working data register</description>
          <addressOffset>0x403A0114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_CHAN_WORK_VALID register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK6</name>
          <description>Channel6 working data register</description>
          <addressOffset>0x403A0118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_CHAN_WORK_VALID register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK7</name>
          <description>Channel7 working data register</description>
          <addressOffset>0x403A011C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_CHAN_WORK_VALID register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT0</name>
          <description>Channel0 result data register</description>
          <addressOffset>0x403A0180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT1</name>
          <description>Channel1 result data register</description>
          <addressOffset>0x403A0184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT2</name>
          <description>Channel2 result data register</description>
          <addressOffset>0x403A0188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT3</name>
          <description>Channel3 result data register</description>
          <addressOffset>0x403A018C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT4</name>
          <description>Channel4 result data register</description>
          <addressOffset>0x403A0190</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT5</name>
          <description>Channel5 result data register</description>
          <addressOffset>0x403A0194</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT6</name>
          <description>Channel6 result data register</description>
          <addressOffset>0x403A0198</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT7</name>
          <description>Channel7 result data register</description>
          <addressOffset>0x403A019C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_VALID_MIR</name>
              <description>Mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK_VALID</name>
          <description>Channel working data register valid bits</description>
          <addressOffset>0x403A0200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CHAN_WORK_VALID</name>
              <description>If set the corresponding WORK data is valid, i.e. was already sampled during the current scan.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT_VALID</name>
          <description>Channel result data register valid bits</description>
          <addressOffset>0x403A0204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CHAN_RESULT_VALID</name>
              <description>If set the corresponding RESULT data is valid, i.e. was sampled during the last scan.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Current status of internal SAR registers (mostly for debug)</description>
          <addressOffset>0x403A0208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>AVG_STAT</name>
          <description>Current averaging status (for debug)</description>
          <addressOffset>0x403A020C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x403A0210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EOS_INTR</name>
              <description>End Of Scan Interrupt</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_INTR</name>
              <description>Overflow Interrupt</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_INTR</name>
              <description>Firmware Collision Interrupt</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_INTR</name>
              <description>DSI Collision Interrupt</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_INTR</name>
              <description>Injection End of Conversion Interrupt</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR</name>
              <description>Injection Saturation Interrupt</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR</name>
              <description>Injection Range detect Interrupt</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR</name>
              <description>Injection Collision Interrupt</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Not really a register, intended for verification/debug. When read, this register reflects the interrupt request register.</description>
          <addressOffset>0x403A0214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EOS_INTR</name>
              <description>End Of Scan Interrupt</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_INTR</name>
              <description>Overflow Interrupt</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_INTR</name>
              <description>Firmware Collision Interrupt</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_INTR</name>
              <description>DSI Collision Interrupt</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_INTR</name>
              <description>Injection End of Conversion Interrupt</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR</name>
              <description>Injection Saturation Interrupt</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR</name>
              <description>Injection Range detect Interrupt</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR</name>
              <description>Injection Collision Interrupt</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x403A0218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EOS_INTR</name>
              <description>End Of Scan Interrupt</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_INTR</name>
              <description>Overflow Interrupt</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_INTR</name>
              <description>Firmware Collision Interrupt</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_INTR</name>
              <description>DSI Collision Interrupt</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_INTR</name>
              <description>Injection End of Conversion Interrupt</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR</name>
              <description>Injection Saturation Interrupt</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR</name>
              <description>Injection Range detect Interrupt</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR</name>
              <description>Injection Collision Interrupt</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x403A021C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EOS_INTR</name>
              <description>End Of Scan Interrupt</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_INTR</name>
              <description>Overflow Interrupt</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_INTR</name>
              <description>Firmware Collision Interrupt</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_INTR</name>
              <description>DSI Collision Interrupt</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_INTR</name>
              <description>Injection End of Conversion Interrupt</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR</name>
              <description>Injection Saturation Interrupt</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR</name>
              <description>Injection Range detect Interrupt</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR</name>
              <description>Injection Collision Interrupt</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR</name>
          <description>Saturate interrupt request register</description>
          <addressOffset>0x403A0220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SATURATE_INTR</name>
              <description>Saturate Interrupt</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_SET</name>
          <description>Saturate interrupt set request register</description>
          <addressOffset>0x403A0224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SATURATE_INTR</name>
              <description>Saturate Interrupt</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_MASK</name>
          <description>Saturate interrupt mask register</description>
          <addressOffset>0x403A0228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SATURATE_INTR</name>
              <description>Saturate Interrupt</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_MASKED</name>
          <description>Saturate interrupt masked request register</description>
          <addressOffset>0x403A022C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SATURATE_INTR</name>
              <description>Saturate Interrupt</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR</name>
          <description>Range detect interrupt request register</description>
          <addressOffset>0x403A0230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RANGE_INTR</name>
              <description>Range detect Interrupt</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_SET</name>
          <description>Range detect interrupt set request register</description>
          <addressOffset>0x403A0234</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RANGE_INTR</name>
              <description>Range detect Interrupt</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_MASK</name>
          <description>Range detect interrupt mask register</description>
          <addressOffset>0x403A0238</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RANGE_INTR</name>
              <description>Range detect Interrupt</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_MASKED</name>
          <description>Range interrupt masked request register</description>
          <addressOffset>0x403A023C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RANGE_INTR</name>
              <description>Range detect Interrupt</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x403A0240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>MUX_SWITCH0</name>
          <description>SARMUX Firmware switch controls</description>
          <addressOffset>0x403A0300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>MUX_SWITCH_CLEAR0</name>
          <description>SARMUX Firmware switch control clear</description>
          <addressOffset>0x403A0304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>MUX_SWITCH1</name>
          <description>SARMUX Firmware switch controls</description>
          <addressOffset>0x403A0308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>MUX_SWITCH_CLEAR1</name>
          <description>SARMUX Firmware switch control clear</description>
          <addressOffset>0x403A030C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>MUX_SWITCH_HW_CTRL</name>
          <description>SARMUX switch hardware control</description>
          <addressOffset>0x403A0340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>MUX_SWITCH_STATUS</name>
          <description>SARMUX switch status</description>
          <addressOffset>0x403A0348</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>PUMP_CTRL</name>
          <description>Switch pump control</description>
          <addressOffset>0x403A0380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>ANA_TRIM</name>
          <description>Analog trim register</description>
          <addressOffset>0x403A0F00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>WOUNDING</name>
          <description>SAR wounding register</description>
          <addressOffset>0x403A0F04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WOUND_RESOLUTION</name>
              <description>Maximum SAR resolution allowed</description>
              <lsb>0</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CAN</name>
      <description>No description available</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CAN_CAN_INT_SR</name>
          <description>The interrupt status register stores internal interrupt events.  ? Once a bit is set it remains set until it is cleared by writing a '1' to it.  ? The interrupt enable register has no effect on the interrupt status register.  ? A pending interrupt occurs when the flag is set to '1'. To acknowledge an interrupt, set the flag to '1'</description>
          <addressOffset>0x402E0000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ARB_LOSS</name>
              <description>Arbitration Loss</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OVR_LOAD</name>
              <description>Overload Interrupt</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR</name>
              <description>Bit Error Interrupt</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STUF_ERR</name>
              <description>Stuff Error Interrupt</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ACK_ERR</name>
              <description>Ack Error Interrupt</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FORM_ERR</name>
              <description>Form Error Interrupt</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_ERR</name>
              <description>CRC Error Interrupt</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_OFF</name>
              <description>Bus Off State</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG_LOSS</name>
              <description>Rx msg loss Interrupt</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG</name>
              <description>Tx msg Sent</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG</name>
              <description>Msg Recieved</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RTR_MSG</name>
              <description>RTR auto-reply message sent</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STUCK_AT_ZERO</name>
              <description>Stuck at dominant error</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SST_FAILURE</name>
              <description>Single shot transmission failure</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_BUF_SR</name>
          <description>These status indicators bundle the respective flags from all RxMessage and TxMessage buffers.  ? Note All flags are read only. To acknowledge a MsgAv flag, the CPU must write to the respective RxMessage buffer</description>
          <addressOffset>0x402E0008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RX_MSG0</name>
              <description>Rx Msg0 Available</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG1</name>
              <description>Rx Msg1 Available</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG2</name>
              <description>Rx Msg2 Available</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG3</name>
              <description>Rx Msg3 Available</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG4</name>
              <description>Rx Msg4 Available</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG5</name>
              <description>Rx Msg5 Available</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG6</name>
              <description>Rx Msg6 Available</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG7</name>
              <description>Rx Msg7 Available</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG8</name>
              <description>Rx Msg8 Available</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG9</name>
              <description>Rx Msg9 Available</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG10</name>
              <description>Rx Msg10 Available</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG11</name>
              <description>Rx Msg11 Available</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG12</name>
              <description>Rx Msg12 Available</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG13</name>
              <description>Rx Msg13 Available</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG14</name>
              <description>Rx Msg14 Available</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_MSG15</name>
              <description>Rx Msg15 Available</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG0</name>
              <description>Tx req Pending for Tx Msg0</description>
              <lsb>16</lsb>
              <msb>16</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG1</name>
              <description>Tx req Pending for Tx Msg1</description>
              <lsb>17</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG2</name>
              <description>Tx req Pending for Tx Msg2</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG3</name>
              <description>Tx req Pending for Tx Msg3</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG4</name>
              <description>Tx req Pending for Tx Msg4</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG5</name>
              <description>Tx req Pending for Tx Msg5</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG6</name>
              <description>Tx req Pending for Tx Msg6</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_MSG7</name>
              <description>Tx req Pending for Tx Msg7</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_ERR_SR</name>
          <description>Status indicators are provided to report the CAN controller error state, receive error count, and transmit error count. ? Special flags report error counter values equal to or in excess of 96 errors are available to indicate heavily disturbed bus situations.  ? The transmitter error counter according to the CAN standard. When it is greater than 255 Decimal, it is fixed at 255 Decimal.</description>
          <addressOffset>0x402E000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TX_ERR_CNT</name>
              <description>Tx error Count</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ERR_CNT</name>
              <description>Rx error Count. When in bus-off state,this counter is used to count 128 groups of 11 recessive bits</description>
              <lsb>8</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_STATE</name>
              <description>Error State of CAN node, 00 error active, 01 error passive, 1x bus off</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGTE96</name>
              <description>Tx Error Count is greater or equal to 96 Decimal</description>
              <lsb>18</lsb>
              <msb>18</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RXGTE96</name>
              <description>Rx Error Count is greater or equal to 96 Decimal</description>
              <lsb>19</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_ECR</name>
          <description>The Error Capture register operates in two different modes: ? Free running mode - ECR displays the fiels and bit positions within the current CAN frame ? Error Capture mode - ECR samples the field and bit position when a CAN error is detected ? In order to sample such an event, the ECR needs to be armed by performing a write access to it. ? When armed, the ECR only captures one error event.  ? For successive error captures, the ECR needs to be armed again.</description>
          <addressOffset>0x402E0018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ECR_STATUS</name>
              <description>ECR STATUS: ?         0: ECR register captured an error, or it is in free running mode ?         1: ECR register is armed</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERROR_TYPE</name>
              <description>Error type: ?         000 : Arbitration loss ?         001 : Bit Error ?         010 : Bit Stuffing Error ?         011 : Acknowledge Error ?         100 : Form Error ?         101 : CRC Error ?         Others : N/A</description>
              <lsb>1</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_MODE</name>
              <description>RX Mode: ?         0: No status ?         1: CAN Controller is receiver</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_MODE</name>
              <description>TX Mode: ?         0: No status ?         1: CAN Controller is transmitter</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>BIT</name>
              <description>Bit number inside of Field</description>
              <lsb>6</lsb>
              <msb>11</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>Field</name>
              <description>Field: ?         0x00 : Stopped ?         0x01 : Synchronize ?         0x05 : Interframe ?         0x06 : Bus Idle ?         0x07 : Start of Frame ?         0x08 : Arbitration ?         0x09 : Control ?         0x0A : Data ?         0x0B : CRC ?         0x0C : ACK ?         0x0D : End of frame ?         0x10 : Error flag ?         0x11 : Error echo ?         0x12 : Error delimiter ?         0x18 : Overload flag ?         0x19 : Overload echo ?         0x1A : Overload delimiter ?         Others : N/A</description>
              <lsb>12</lsb>
              <msb>16</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX0_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402E0024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX0_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX0_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402E002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX1_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402E0034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX1_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX1_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402E003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX2_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402E0044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX2_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX2_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402E004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX3_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402E0054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX3_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX3_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402E005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX4_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402E0064</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX4_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0068</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX4_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402E006C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX5_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402E0074</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX5_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX5_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402E007C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX6_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402E0084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX6_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX6_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402E008C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX7_ID</name>
          <description>CAN Tx Msg Identifier</description>
          <addressOffset>0x402E0094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Tx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX7_DH</name>
          <description>CAN Tx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_TX7_DL</name>
          <description>CAN Tx Msg Lower Data Bytes</description>
          <addressOffset>0x402E009C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX0_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E00A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX0_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E00A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX0_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E00AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX1_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E00C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX1_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E00C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX1_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E00CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX2_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E00E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX2_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E00E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX2_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E00EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX3_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E0104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX3_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX3_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E010C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX4_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E0124</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX4_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0128</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX4_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E012C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX5_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E0144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX5_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX5_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E014C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX6_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E0164</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX6_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0168</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX6_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E016C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX7_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E0184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX7_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX7_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E018C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX8_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E01A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX8_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E01A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX8_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E01AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX9_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E01C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX9_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E01C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX9_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E01CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX10_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E01E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX10_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E01E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX10_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E01EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX11_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E0204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX11_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX11_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E020C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX12_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E0224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX12_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX12_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E022C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX13_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E0244</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX13_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0248</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX13_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E024C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX14_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E0264</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX14_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0268</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX14_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E026C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX15_ID</name>
          <description>The register contains Rx Msg Identifier</description>
          <addressOffset>0x402E0284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ZEROES</name>
              <description>zeros</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ID</name>
              <description>Rx Msg Indentifier</description>
              <lsb>3</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX15_DH</name>
          <description>The register contains the Rx Msg Upper Data Bytes</description>
          <addressOffset>0x402E0288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_HIGH</name>
              <description>Upper Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAN_CAN_RX15_DL</name>
          <description>The register contains the Rx Msg Lover Data Bytes</description>
          <addressOffset>0x402E028C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_LOW</name>
              <description>Lower Data Bytes</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>